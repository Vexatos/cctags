local args = { ... }

local reader_side = args[1]
if not reader_side then
    print("Usage: reader <peripheral side>, [<move forward on start = true>], [<max security level = 3>]")
    return
end

--TODO: Get better
local forward_start = not ((args[2] == '0') or (args[2] == 'false'))

local work_env = tags.setup_env()

if reader_side == 'print' then
    local w,h = term.getSize()
    local s = {}
    for k,_ in pairs(work_env) do
        table.insert(s, k)
    end
    
    print(table.concat(s, ','))
    return
end

if fs.exists("follow-env") then
    os.run(work_env, "follow-env")
end

work_env["reader"] = reader_side

if forward_start then
    if not turtle.forward() then
        error("Can't move forward")
    end
end

work_env.prev = function() end
work_env.step = 0

local function stack(initial)
    local empty = {
        value = initial
    }
    
    empty.prev = empty
    
    local head = empty
    
    local result = {}
    
    function result.push(v)
        head = {
            value = v,
            prev = head
        }
    end
    
    function result.pop()
        local c = head.value
        head = head.prev
        return c
    end
    
    function result.top()
        return head.value
    end
    
    function result.clear()
        head = empty
    end
    
    return result
end

local postamble = stack(function() end)
work_env.pushPostamble = postamble.push
work_env.popPostamble = postamble.pop
function work_env.pausePostamble() 
    local p = postamble.pop()
    postamble.push(function () end)
    p()
end

local values = stack(nil)
work_env._args = values
function work_env.push(value) 
    values.push(value)
    print('Push: ' .. tostring(value))
end

function work_env.pop()
    value = values.pop()
    print('Pop: ' .. tostring(value))
    return value 
end
work_env.top = values.top

work_env._counters = {}

local finished = false
local lastSerial = 0

function work_env.stop() 
    finished = true
    postamble.clear()
    print("stop(): finished")
end

local function createSimpleExecutor()
    return function (fun, contents)
        print(string.format("Step %d: executing: '%s'", work_env.step, contents))
        return pcall(fun)
    end
end

local function createDummyExecutor()
    return function (fun, contents)
        print(string.format("Step %d: ignoring: '%s'", work_env.step, contents))
        return true
    end
end

local function createSavingExecutor(execute)
    local result = {}
    
    setmetatable(result, {
        __call = function(self, fun, contents)
            print(string.format("Step %d: storing: '%s'", work_env.step, contents))
            table.insert(self, fun)
            
            if execute then
                return pcall(fun)
            end
            
            return true
        end
    })
    
    return result
end

local executor = createSimpleExecutor()

local controlActions = {}

controlActions['!pause'] = function ()
    executor =  createDummyExecutor()
end

controlActions['!restore'] = function ()
    executor =  createSimpleExecutor()
end

controlActions['!record'] = function ()
    executor =  createSavingExecutor(false)
end

controlActions['!record-execute'] = function ()
    executor =  createSavingExecutor(true)
end

controlActions['!save'] = function()
    if type(executor) ~= 'table' then
        error("Trying to 'save' without calling 'record'") 
    end

    local macro = executor
    executor = createSimpleExecutor()
   
    local function callMacro()
        for i,v in ipairs(macro) do
            v()
        end
    end
   
    values.push(callMacro)
    
end

while not finished do
    local dir, contents, _, _, serial = tags.scanForTags(reader_side)
    
    if not dir then
        error("No tag found")
    end
    
    if serial == lastSerial then
        error("Tag " .. serial .. " was read twice in row")
    end
    
    lastSerial = serial
     
    work_env.tagDir = dir
    work_env.serial = serial
    work_env.step = work_env.step + 1
    
    local updatePrev = true
    
    function work_env.holdPrev()
        updatePrev = false
    end 
    
    local action = controlActions[contents]
    if action then
        action()
        print(string.format("Step %d: command '%s'", work_env.step, contents))
    else 
        local operation, e = loadstring(contents)
        if not operation then
            error(string.format("Invalid operation, error: '%s'", operation, err))
        end
        
        setfenv(operation, work_env)
        local status, result = executor(operation, contents)
        
        if not status then
            error("Error during command execution: " .. result)
        end
        
        if updatePrev then
            work_env.prev = operation
        end
        
        if result then
            print(string.format("Step %d: result: '%s'", work_env.step, tostring(result)))
        end
    end
    
    postamble.top()()
end