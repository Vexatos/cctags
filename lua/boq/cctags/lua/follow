local args = { ... }

local reader_side = args[1]
if not reader_side then
    print("Usage: reader <peripheral side>, [<move forward on start = true>], [<max security level = 3>]")
    return
end

--TODO: Get better
local forward_start = not ((args[2] == '0') or (args[2] == 'false'))
local max_level = tonumber(args[3]) or 3
local work_env = {}
local full_env = tags.envs(work_env) -- declared functions may want to see inside work_env

for name,data in pairs(full_env) do
    env, level, is_global = unpack(data)
    if level <= max_level then
        if is_global then
            for k,v in pairs(env) do
                work_env[k] = v
             end
        else
            work_env[name] = env
        end
    end 
end

if reader_side == 'print' then
    local w,h = term.getSize()
    local s = {}
    for k,_ in pairs(work_env) do
        table.insert(s, k)
    end
    
    print(table.concat(s, ','))
    return
end

if fs.exists("follow-env") then
    os.run(work_env, "follow-env")
end

work_env["reader"] = reader_side

if forward_start then
    if not turtle.forward() then
        error("Can't move forward")
    end
end

work_env.prev = function() end
work_env.step = 0

local function stack(initial)
    local empty = {
        value = initial
    }
    
    empty.prev = empty
    
    local head = empty
    
    local result = {}
    
    function result.push(v)
        head = {
            value = v,
            prev = head
        }
    end
    
    function result.pop()
        local c = head.value
        head = head.prev
        return c
    end
    
    function result.top()
        return head.value
    end
    
    function result.clear()
        head = empty
    end
    
    return result
end

local postamble = stack(function() end)
work_env.pushPostamble = postamble.push
work_env.popPostamble = postamble.pop
function work_env.pausePostamble() 
    local p = postamble.pop()
    postamble.push(function () end)
    p()
end

local values = stack(nil)
work_env._args = values
function work_env.push(value) 
    values.push(value)
    print('Push: ' .. tostring(value))
end

function work_env.pop()
    value = values.pop()
    print('Pop: ' .. tostring(value))
    return value 
end
work_env.top = values.top

work_env._counters = {}

local finished = false
local lastSerial = 0

function work_env.stop() 
    finished = true
    postamble.clear()
    print("stop(): finished")
end

while not finished do
    local dir, contents, _, _, serial = tags.scanForTags(reader_side)
    
    if not dir then
        error("No tag found")
    end
    
    if serial == lastSerial then
        error("Tag " .. serial .. " was read twice in row")
    end
    
    lastSerial = serial
     
    work_env.tagDir = dir
    work_env.serial = serial
    work_env.step = work_env.step + 1
    
    local updatePrev = true
    
    function work_env.holdPrev()
        updatePrev = false
    end 
    
    print(string.format("Step %d: executing: '%s'", work_env.step, contents))
    
    local operation, e = loadstring(contents)
    if not operation then
        error(string.format("Invalid operation, error: '%s'", operation, err))
    end
    
    setfenv(operation, work_env)
    local status, result = pcall(operation)
    
    if not status then
        error("Error during command execution: " .. result)
    end
    
    if updatePrev then
        work_env.prev = operation
    end
    
    postamble.top()()
    
    if result then
        print(string.format("%Step d: result: '%s'", work_env.step, result))
    end
end