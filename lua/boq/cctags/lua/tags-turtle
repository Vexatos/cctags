local function isReader(t)
    return t == "tag_writer" or t == "tag_printer"
end

function getPeripheral(side)
    local t = peripheral.getType(side)
    if not isReader(t) then
        error("Invalid peripheral type " .. t .. " on side " .. side)
    end
    return peripheral.wrap(side), t
end

DIRECTIONS = {"up", "down", "front", "back", "left", "right"}
function scanForTags(side, dirs)
    local dirs = dirs or DIRECTIONS
    local p = getPeripheral(side)
    for _,dir in pairs(DIRECTIONS) do
        if p.scanForTag(dir) then
            local contents, size = p.contents()
            return dir, contents, size, p.size(), p.serial()
        end
    end
end

local function subset(source, ...)
    local result = {}
    local names = { ... }
    for _,name in pairs(names) do
        result[name] = source[name]
    end
    
    return result
end

-- turtle envs
local safest = {
    print = print,
}

local safe = {
    pullEvent = os.pullEvent,
    scan = scanForTags,
    read = read
}

function safe.writeTag(side, contents)
    local p = getPeripheral(side)
    p.write(contents)
end

function safe.readTag(side)
    local p = getPeripheral(side)
    local contents, size = p.contents()
    return contents, size, p.size()
end

function twice(action)
        return function() action() action() end
    end

local turtleRotate = {
    left = turtle.turnLeft,
    right = turtle.turnRight,
    back = twice(turtle.turnRight)
}

local turtleReverse = {
    left = turtle.turnRight,
    right = turtle.turnLeft,
    back = twice(turtle.turnLeft)
}

local function selectAction(list, arg)
    local action = list[arg]
    if action then
        action()
    end
end

local turtle_safe_hidden = subset(turtle,
    "forward",
    "back",
    "up",
    "down",
    
    "detect",
    "detectUp",
    "detectDown",
    
    "compare",
    "compareUp",
    "compareDown",
    
    "drop",
    "dropUp",
    "dropDown",
    
    "suck",
    "suckUp",
    "suckDown"
)

local turtle_safe_global = subset(turtle, 
    "turnLeft",
    "turnRight",

    "select",
    "transferTo",
    "getItemCount",
    "getItemSpace",
    
    "compareTo",
    
    "refuel",
    "getFuelLevel"
)

local function dirAction(normal, up, down)
    return function(side, reverse, ...)
        local args = {...}
        if side then
            selectAction(turtleRotate, side)
            
            if action == "up" then
                up(unpack(args))
            elseif action == "down" then
                down(unpack(args))
            else
                normal(unpack(args))
            end
            
            selectAction(turtleReverse, side)
        else
            action(unpack(args))
        end
    end
end

local unsafe = {
    attack = dirAction(turtle.attack, turtle.attackUp, turtle.attackDown),
    dig = dirAction(turtle.dig, turtle.digUp, turtle.digDown),
}

-- it's a big function, but we want to inject out variables (`vars') into scope during function declaration
function envs(vars)
    local function waitForMove()
        while true do
            local dir, _, _, _, current = scanForTags(vars.reader)
            if current then
                print(current .. " " .. (vars.serial or "?"))
            end
            
            if not dir or vars.serial ~= current then
                break
            end
        end
    end

    function moveUntilTag(action)
        return function()
            if not action() then
                print("Error during movement. Aborting!")
                return
            end
            
            waitForMove() --wait until we move away from current tag
            while true do
                local dir = scanForTags(vars.reader)
                if dir then
                    break
                end
                
                if not action() then
                    print("Error during movement. Aborting!")
                    break
                end
                sleep(0.5)
            end
        end
    end    

    local move = {
        forward = moveUntilTag(turtle.forward),
        back = moveUntilTag(turtle.back),
        up = moveUntilTag(turtle.up),
        down = moveUntilTag(turtle.down),
        detect = dirAction(turtle.detect, turtle.detectUp, turtle.detectDown),
        compare = dirAction(turtle.compare, turtle.compareUp, turtle.compareDown),
        drop = dirAction(turtle.drop, turtle.dropUp, turtle.dropDown),
        suck = dirAction(turtle.suck, turtle.suckUp, turtle.suckDown)
    }
    
    function move.rotate(side)
        selectAction(turtleRotate, side)
    end
        -- Warning: following table is probably horribly unaccurate and arbitrary
    return {
        -- probably safe
        _dummy0 = {safest, 0, true},
        term = {term, 0},
        colors = {colors, 0},
        colours = {colours, 0},
        vector = {vector, 0},
        keys = {keys, 0},
        
        -- may block/slow down execution (?)
        _dummy1 = {safe, 1, true},
        textutils = {textutils, 1},
        gps = {gps, 1},
        
        -- minor world interaction
        rednet = {rednet, 2},
        t = {turtle_safe_hidden, 2},
        _dummy2 = {turtle_safe_global, 2, true},
        _dummy3 = {move, 2, true},
        
        -- full world interaction
        _dummy4 = {unsafe, 3, true},
        turtle = {turtle, 3}
    }
end