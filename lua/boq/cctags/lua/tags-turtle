local function isReader(t)
    return t == "tag_writer" or t == "tag_printer"
end

function getPeripheral(side)
    local t = peripheral.getType(side)
    if not isReader(t) then
        error("Invalid peripheral type " .. t .. " on side " .. side)
    end
    return peripheral.wrap(side), t
end

DIRECTIONS = {"up", "down", "front", "back", "left", "right"}
function scanForTags(side, dirs)
    local dirs = dirs or DIRECTIONS
    local p = getPeripheral(side)
    for _,dir in pairs(DIRECTIONS) do
        if p.scanForTag(dir) then
            local contents, size = p.contents()
            return dir, contents, size, p.size(), p.serial()
        end
    end
end

local function subset(source, ...)
    local result = {}
    local names = { ... }
    for _,name in pairs(names) do
        result[name] = source[name]
    end
    
    return result
end

-- turtle envs
local safest = {
    print = print,
}

local safe = {
    pullEvent = os.pullEvent,
    scan = scanForTags,
    read = read
}

function safe.writeTag(side, contents)
    local p = getPeripheral(side)
    p.write(contents)
end

function safe.readTag(side)
    local p = getPeripheral(side)
    local contents, size = p.contents()
    return contents, size, p.size()
end

function twice(action)
        return function() action() action() end
    end

local turtleRotate = {
    left = turtle.turnLeft,
    right = turtle.turnRight,
    back = twice(turtle.turnRight)
}

local turtleReverse = {
    left = turtle.turnRight,
    right = turtle.turnLeft,
    back = twice(turtle.turnLeft)
}

local function selectAction(list, arg)
    local action = list[arg]
    if action then
        action()
    end
end

local function dirAction(normal, up, down)
    return function(side, reverse, ...)
        local args = {...}
        if side then
            selectAction(turtleRotate, side)
            
            local result
            if side == "up" then
                result = up(unpack(args))
            elseif side == "down" then
                result = down(unpack(args))
            else
                result = normal(unpack(args))
            end
            
            selectAction(turtleReverse, side)
            return result
        else
            return normal(unpack(args))
        end
    end
end

local unsafe = {
    attack = dirAction(turtle.attack, turtle.attackUp, turtle.attackDown),
    dig = dirAction(turtle.dig, turtle.digUp, turtle.digDown),
}

-- it's a big function, but we want to inject out variables (`vars') into scope during function declaration and delay few things until APIs are loaded
function envs(vars)

    -- turtle API has some loading logic, so we need to delay creation of those tables
    turtle_safe_hidden = subset(turtle,
        "forward",
        "back",
        "up",
        "down",
        
        "detect",
        "detectUp",
        "detectDown",
        
        "compare",
        "compareUp",
        "compareDown",
        
        "drop",
        "dropUp",
        "dropDown",
        
        "suck",
        "suckUp",
        "suckDown"
    )

    turtle_safe_global = subset(turtle, 
        "turnLeft",
        "turnRight",

        "select",
        "transferTo",
        "getItemCount",
        "getItemSpace",
        
        "compareTo",
        
        "refuel",
        "getFuelLevel"
    )

    function moveUntilTag(action)
        return function()
            while true do
                if not action() then
                    print("Error during movement. Aborting!")
                    break
                end
                
                local dir = scanForTags(vars.reader)
                if dir then
                    break
                end
            end
        end
    end    

    local move = {
        forward = moveUntilTag(turtle.forward),
        back = moveUntilTag(turtle.back),
        up = moveUntilTag(turtle.up),
        down = moveUntilTag(turtle.down),
        detect = dirAction(turtle.detect, turtle.detectUp, turtle.detectDown),
        compare = dirAction(turtle.compare, turtle.compareUp, turtle.compareDown),
        drop = dirAction(turtle.drop, turtle.dropUp, turtle.dropDown),
        suck = dirAction(turtle.suck, turtle.suckUp, turtle.suckDown)
    }
    
    function move.rotate(side)
        selectAction(turtleRotate, side)
    end
    
    local safe_env = {}
    
    function safe_env.restorePrev()
        vars.holdPrev()
        vars.prev()
    end
    
        -- Warning: following table is probably horribly unaccurate and arbitrary
    return {
        -- probably safe
        _dummy10 = {safest, 0, true},
        _dummy20 = {safe_env, 0, true},
        term = {term, 0},
        colors = {colors, 0},
        colours = {colours, 0},
        vector = {vector, 0},
        keys = {keys, 0},
        
        -- may block/slow down execution (?)
        _dummy30 = {safe, 1, true},
        textutils = {textutils, 1},
        gps = {gps, 1},
        
        -- minor world interaction
        rednet = {rednet, 2},
        t = {turtle_safe_hidden, 2},
        _dummy40 = {turtle_safe_global, 2, true},
        _dummy50 = {move, 2, true},
        
        -- full world interaction
        _dummy60 = {unsafe, 3, true},
        turtle = {turtle, 3}
    }
end