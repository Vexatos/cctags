local function isReader(t)
    return t == "tag_writer" or t == "tag_printer"
end

function getPeripheral(side)
    local t = peripheral.getType(side)
    if not isReader(t) then
        error("Invalid peripheral type " .. t .. " on side " .. side)
    end
    return peripheral.wrap(side), t
end

DIRECTIONS = {"up", "down", "front", "back", "left", "right"}
function scanForTags(side, dirs)
    local dirs = dirs or DIRECTIONS
    local p = getPeripheral(side)
    for _,dir in pairs(DIRECTIONS) do
        if p.scanForTag(dir) then
            local contents, size = p.contents()
            return dir, contents, size, p.size(), p.serial()
        end
    end
end

local function subset(source, ...)
    local result = {}
    local names = { ... }
    for _,name in pairs(names) do
        result[name] = source[name]
    end
    
    return result
end

-- turtle envs
local safest = {
    print = print,
}

local safe = {
    pullEvent = os.pullEvent,
    scan = scanForTags,
    read = read,
    sleep = os.sleep
}

function safe.writeTag(side, contents)
    local p = getPeripheral(side)
    p.write(contents)
end

function safe.readTag(side)
    local p = getPeripheral(side)
    local contents, size = p.contents()
    return contents, size, p.size()
end

function twice(action)
        return function() action() action() end
    end

local function selectAction(list, arg)
    local action = list[arg]
    if action then
        action()
    end
end

-- it's a big function, but we want to inject out variables (`vars') into scope during function declaration and delay few things until APIs are loaded
function envs(vars)

    function unaryStackFun(fun)
        return function()
            local arg = vars.pop()
            local result = fun(arg)
            vars.push(result)
        end
    end
    
    function binaryStackFun(fun)
        return function()
            local arg1 = vars.pop()
            local arg2 = vars.pop()
            local result = fun(arg1, arg2)
            vars.push(result)
        end
    end
    
    local logic = {
        and_ = binaryStackFun(function(a,b) return a and b end),
        or_ = binaryStackFun(function(a,b) return a or b end),
        not_ = unaryStackFun(function(a) return not a end)
    }
    
    local relational = {
        eq = binaryStackFun(function(a,b) return a == b end),
        neq = binaryStackFun(function(a,b) return a ~= b end),
        gt = binaryStackFun(function(a,b) return a > b end),
        lt = binaryStackFun(function(a,b) return a < b end),
        ge = binaryStackFun(function(a,b) return a >= b end),
        le = binaryStackFun(function(a,b) return a <= b end)
    }
    
    local arithmetic = {
        add = binaryStackFun(function(a,b) return a - b end),
        sub = binaryStackFun(function(a,b) return a + b end),
        mul = binaryStackFun(function(a,b) return a * b end),
        div = binaryStackFun(function(a,b) return a / b end),
        neg = unaryStackFun(function(a) return -a end),
        inc = unaryStackFun(function(a) return a + 1 end),
        dec = unaryStackFun(function(a) return a - 1 end),
    }
    
    local stack = {}
    
    function stack.cond(fun, ...)
        local condition = vars.pop()
        if condition then
            return fun(...)
        end
    end
    
    function stack.check(fun, ...)
        local result = fun(...)
        vars.push(result)
        return result
    end

    -- turtle API has some loading logic, so we need to delay creation of those tables
    turtle_safe_hidden = subset(turtle,
        "forward",
        "back",
        "up",
        "down",
        
        "detect",
        "detectUp",
        "detectDown",
        
        "compare",
        "compareUp",
        "compareDown",
        
        "drop",
        "dropUp",
        "dropDown",
        
        "suck",
        "suckUp",
        "suckDown"
    )

    turtle_safe_global = subset(turtle, 
        "turnLeft",
        "turnRight",

        "select",
        "transferTo",
        "getItemCount",
        "getItemSpace",
        
        "compareTo",
        
        "refuel",
        "getFuelLevel"
    )

    function moveUntilTag(action)
        return function()
            while true do
                if not action() then
                    print("Error during movement. Aborting!")
                    break
                end
                
                local dir = scanForTags(vars.reader)
                if dir then
                    break
                end
            end
        end
    end    

    local turtleRotate = {
        left = turtle.turnLeft,
        right = turtle.turnRight,
        back = twice(turtle.turnRight)
    }

    local turtleReverse = {
        left = turtle.turnRight,
        right = turtle.turnLeft,
        back = twice(turtle.turnLeft)
    }
    
    local function dirAction(normal, up, down)
        return function(side, reverse, ...)
            local args = {...}
            if side then
                selectAction(turtleRotate, side)
                
                local result
                if side == "up" then
                    result = up(unpack(args))
                elseif side == "down" then
                    result = down(unpack(args))
                else
                    result = normal(unpack(args))
                end
                
                selectAction(turtleReverse, side)
                return result
            else
                return normal(unpack(args))
            end
        end
    end
    
    local unsafe = {
        attack = dirAction(turtle.attack, turtle.attackUp, turtle.attackDown),
        dig = dirAction(turtle.dig, turtle.digUp, turtle.digDown),
    }

    local move = {
        forward = moveUntilTag(turtle.forward),
        back = moveUntilTag(turtle.back),
        up = moveUntilTag(turtle.up),
        down = moveUntilTag(turtle.down),
    }
    
    function move.rotate(side)
        selectAction(turtleRotate, side)
    end
    
    function move.orient(targetDir)
        local orientToIndex = {
            front = 0,
            right = 1,
            back = 2,
            left = 3
        }
    
        local indexToAction = {
            function() end,
            turtle.turnRight,
            twice(turtle.turnLeft),
            turtle.turnLeft
        }
    
        local targetIndex = orientToIndex[targetDir]
        if not targetIndex then
            error("Invalid direction: " .. targetDir)
        end
        
        local tagDir = vars.tagDir
        print(tagDir)
        local tagIndex = orientToIndex[tagDir]
        if tagIndex then
            local result = (tagIndex - targetIndex) % 4
            print("Res: " .. result)
            indexToAction[result + 1]()
        end
    end
    
    local inv = {
        drop = dirAction(turtle.drop, turtle.dropUp, turtle.dropDown),
        suck = dirAction(turtle.suck, turtle.suckUp, turtle.suckDown)
    }
    
    local checks = {
        detect = dirAction(turtle.detect, turtle.detectUp, turtle.detectDown),
        compare = dirAction(turtle.compare, turtle.compareUp, turtle.compareDown)
    }

    local safe_env = {}
    
    function safe_env.restorePrev()
        vars.holdPrev()
        vars.prev()
    end
    
        -- Warning: following table is probably horribly unaccurate and arbitrary
    return {
        -- probably safe
        _dummy10 = {safest, 0, true},
        _dummy20 = {safe_env, 0, true},
        _dummy21 = {stack, 0, true},
        _dummy22 = {logic, 0, true},
        _dummy23 = {relational, 0, true},
        _dummy24 = {arithmetic, 0, true},
        
        term = {term, 0},
        colors = {colors, 0},
        colours = {colours, 0},
        vector = {vector, 0},
        keys = {keys, 0},
        math = {math, 0},
        bit = {bit, 0},
        string = {string, 0},
        table = {table, 0},
        
        -- may block/slow down execution (?)
        _dummy30 = {safe, 1, true},
        textutils = {textutils, 1},
        gps = {gps, 1},
        
        -- minor world interaction
        rednet = {rednet, 2},
        t = {turtle_safe_hidden, 2},
        _dummy40 = {turtle_safe_global, 2, true},
        _dummy50 = {move, 2, true},
        _dummy51 = {inv, 2, true},
        _dummy52 = {checks, 2, true},
        
        -- full world interaction
        _dummy60 = {unsafe, 3, true},
        turtle = {turtle, 3},
        os = {os, 3}
    }
end